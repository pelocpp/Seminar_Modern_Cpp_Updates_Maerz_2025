// =========================================

Seminar Updates Modern C++ 

Peter Loos

== Development
== Schulungen

C/C++, Java, C#, Mobile Progr. (Android (Java)), Kotlin , (( Python ))

Back-to-the-Roots:

Guten Morgen

// =========================================

12.30 - 13.30


// =========================================

Online:

2 Tools:

a) Visual Studio IDE

   Samples standardisiert

b) https://github.com/pelocpp

   https://github.com/pelocpp/cpp_modern

Was machen wir ?
Was sind meine Erwartungen ???

Agenda:

Was ist wichtig 
Was MUSS DRIN sein
Was ist nicht so wichtig

C++ 17 

Modern C++

Classic C++

// ============================================================

;..; .... CA0    temp. Objekt   // wird freigegeben
;..; .... 330    Objekt für den Stack

Lösung:

Move-Semantik

;..; .... C30    Objekt für den Stack

===========================================================

Lambdas:

Herleitung.

Aufrufbares Objekt // Callable Object

Was ist ein aufrufbares Objekt ???

Def:

class SomeClass 

SomeClass obj;

auto result = obj.method(1, 2, 3);

auto result = obj(1, 2, 3);   // operator()

auto result = obj[5];  // operator[]

Keep it simple:

Was tut / ist der Operator():

Eigentlich eine gewöhnliche Methode, nur dass diese keinen Namen hat.

Iteratoren:

auto iter;

++iter;                 operator++

*iter;                  operator*

if (iter1 == iter2)     operator==

STL-Container:          begin(), end()

// =============================================

Lambdas:

Was ist ein Lambda: Eine Instanz einer Callable Klasse:

                    Eine Instanz einer 
                    Klasse, die den Operator() überladen tut.


Lambdas:   Was ist ein Lambda: Eine Funktion . NEIN !!!!!!!!!!!!!!!!!!!!!!!!

Lambdas:   Können auf Variablen der Umgebung zugreifen !!!!

// =============================================

Tool:  Cpp Insights.

Valgrind:

// =============================================

Konstanten // Literal

UDL:  User Defined Literal   

Lesbarkeit des Quellcode
Typsicherheit

==> Strong Type:

100l

100ll

123.45f

100_km

100_kg

0xFF0000_farbe  unsigned int => class Color

0xFF0000_rgb

// Bemerkung:

C++:  Lexikon:   anton, while , 123, 123.456, ! , &&, &, ; 

Das Lexikon von C++ ist erweiterbar:  0xFF0000_rgb

How:  operator""   Literal-Operator

// ===========================================

Copy-Move Elision

RVO:  Return Value Optimization

NRVO: Named Return Value Optimization

// ===========================================

Was ist das Problem eines Shared-Ptr Objekts ???

Er funktioniert nicht immer ?!?!?!?!?! No delete !!!

a) std::weak_ptr

b) Was ist das eigentliche Problem ???

Antwort:  Zyklische Referenzen:  A => B   und B => A

Observer - Pattern

a) Subject:  Hat Zustand, der sich ändert // dieser will beobachtet werden.

b) Observer: Kennen das Subject // beobachte.

c) Subject:  Zustand HAT sich geändert // kennt seine Beobachter // informiert diese

d)  Subject: Hat Methoden attach / detach für Observer,
    hat intern eine Liste für alle Observer

MAIN:

Subject: std::shared_ptr

Observer: std::shared_ptr

Liste für alle Observer: Hmmmmmmmmmmmmmmmmm, welchen Datentyp haben die Listenelemente

STRENGE KOPPLUNG

i) std::shared_ptr: Entscheidet Subject über die Lebensdauer von Observer-Objekten. NO

LOSE KOPPLUNG:

ii) std::weak_ptr: Subject entscheidet NICHT über die Lebensdauer von Observer-Objekten.

Subject möchte informieren // lock // nullptr: 

Hmm, Liste wird immer größer mit std::weak_ptr-Leichen

========

Best Practice:  std::shared_ptr oder std::weak_ptr.

Im Nachgang: Ginge ein std::weak_ptr: 

========================================================

Ein Tupel ist ähnlich zu einer Struktur - für Schreibfaule.

Hmmm, mit Structured Binding (also mit Namen) bin ich eng an einer Struktur dran.


========================================================

std::variant:

Kann Variablen unterschiedlichen Typs aufnehmen,
zu einem Zeitpunkt aber nur eine!

Beispiel:

Excel  ==> Zelle / Cell:

Cell:  Zeichenkette, Wert, Datum, Währung (Currency), ...

Game Programming:

Game Board ==> Figure: 

Gleicht einem union:  float-Wert ==> byte array[4]

=============================================================

Beobachtung:

            if (std::is_same<ElemTypeWithoutRefAndConst, int>::value == true) {
00007FF7C729D176  xor         eax,eax               // EAX: Akku  : Schreibt NULL rein.

00007FF7C729D178  cmp         eax,1                 // DER COMPILER WEISS, dass da ne 1 drin steht

00007FF7C729D17B  je          `VariantDemo::test_03'::`2'::<lambda_1>::operator()<int>+7Ah (07FF7C729D1CAh)  

// =======================================================

Variadic Templates:  Hinter den Kulissen

a) Debugger

b)  Cpp  Insights

Why ???????????????????????????????????????

Transport unterschiedlichster Daten von A nach B

a) std::make_unique
   std::make_shared

b) std::thread 

   std::thread t { tproc, 1, 2, 3 };

c) emplace-Technik

